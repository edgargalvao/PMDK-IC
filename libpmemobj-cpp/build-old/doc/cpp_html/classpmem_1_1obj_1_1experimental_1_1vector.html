<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">libpmemobj++/experimental/vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a636c3f33b0647feb03e1caf9aece8ab2">vector</a> ()</td></tr>
<tr class="memdesc:a636c3f33b0647feb03e1caf9aece8ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a636c3f33b0647feb03e1caf9aece8ab2">More...</a><br /></td></tr>
<tr class="separator:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77628ae4d95b0e93037541f104ec86b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a77628ae4d95b0e93037541f104ec86b3">vector</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a77628ae4d95b0e93037541f104ec86b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#a77628ae4d95b0e93037541f104ec86b3">More...</a><br /></td></tr>
<tr class="separator:a77628ae4d95b0e93037541f104ec86b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b0a598e44399198a1f05ee732e576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a486b0a598e44399198a1f05ee732e576">vector</a> (size_type count)</td></tr>
<tr class="memdesc:a486b0a598e44399198a1f05ee732e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of T default constructed values.  <a href="#a486b0a598e44399198a1f05ee732e576">More...</a><br /></td></tr>
<tr class="separator:a486b0a598e44399198a1f05ee732e576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f6b898490147e4c6e620785d5194aa">vector</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae1f6b898490147e4c6e620785d5194aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#ae1f6b898490147e4c6e620785d5194aa">More...</a><br /></td></tr>
<tr class="separator:ae1f6b898490147e4c6e620785d5194aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1167a0629de37532aa57f39da47fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9b1167a0629de37532aa57f39da47fa9">vector</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a9b1167a0629de37532aa57f39da47fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9b1167a0629de37532aa57f39da47fa9">More...</a><br /></td></tr>
<tr class="separator:a9b1167a0629de37532aa57f39da47fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503ab924495ac60140b9852ce7d52b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa503ab924495ac60140b9852ce7d52b0">vector</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa503ab924495ac60140b9852ce7d52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa503ab924495ac60140b9852ce7d52b0">More...</a><br /></td></tr>
<tr class="separator:aa503ab924495ac60140b9852ce7d52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88f2db2da445af0fab25559262c636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7a88f2db2da445af0fab25559262c636">vector</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a7a88f2db2da445af0fab25559262c636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="#a7a88f2db2da445af0fab25559262c636">More...</a><br /></td></tr>
<tr class="separator:a7a88f2db2da445af0fab25559262c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a395a49f38bcde6c2164405fc9bb2c35a">~vector</a> ()</td></tr>
<tr class="memdesc:a395a49f38bcde6c2164405fc9bb2c35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a395a49f38bcde6c2164405fc9bb2c35a">More...</a><br /></td></tr>
<tr class="separator:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8">at</a> (size_type n)</td></tr>
<tr class="memdesc:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking and add it to a transaction.  <a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">More...</a><br /></td></tr>
<tr class="separator:a7b1f1a08b1d34f9874c1d56dce9c8ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db43b38bad316d12f51319fcdb2054"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a83db43b38bad316d12f51319fcdb2054">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a83db43b38bad316d12f51319fcdb2054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a83db43b38bad316d12f51319fcdb2054">More...</a><br /></td></tr>
<tr class="separator:a83db43b38bad316d12f51319fcdb2054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc08c07d12cdacc4426285962f0c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21">const_at</a> (size_type n) const</td></tr>
<tr class="memdesc:a38fc08c07d12cdacc4426285962f0c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index with bounds checking.  <a href="#a38fc08c07d12cdacc4426285962f0c21">More...</a><br /></td></tr>
<tr class="separator:a38fc08c07d12cdacc4426285962f0c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a57b4e5d1c66f006ad7f87f9573f3c6bc">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">More...</a><br /></td></tr>
<tr class="separator:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0ffcc2e74974015ed9741b1430227"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f0ffcc2e74974015ed9741b1430227">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ae1f0ffcc2e74974015ed9741b1430227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#ae1f0ffcc2e74974015ed9741b1430227">More...</a><br /></td></tr>
<tr class="separator:ae1f0ffcc2e74974015ed9741b1430227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5">front</a> ()</td></tr>
<tr class="memdesc:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element and add this element to a transaction.  <a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">More...</a><br /></td></tr>
<tr class="separator:ae5ea56dd1be6b3e5d0427a62327b81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674fdb0401fd0f7396675035d1d8e72a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a674fdb0401fd0f7396675035d1d8e72a">front</a> () const</td></tr>
<tr class="memdesc:a674fdb0401fd0f7396675035d1d8e72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#a674fdb0401fd0f7396675035d1d8e72a">More...</a><br /></td></tr>
<tr class="separator:a674fdb0401fd0f7396675035d1d8e72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb83c8e3bda44858a6923319e880e6"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6">cfront</a> () const</td></tr>
<tr class="memdesc:abbfb83c8e3bda44858a6923319e880e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#abbfb83c8e3bda44858a6923319e880e6">More...</a><br /></td></tr>
<tr class="separator:abbfb83c8e3bda44858a6923319e880e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0014916c3340dfafdcba429a3afd4a"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a">back</a> ()</td></tr>
<tr class="memdesc:a4c0014916c3340dfafdcba429a3afd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element and add this element to a transaction.  <a href="#a4c0014916c3340dfafdcba429a3afd4a">More...</a><br /></td></tr>
<tr class="separator:a4c0014916c3340dfafdcba429a3afd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc2516566c13ec6713c624cdfd2c21"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a01dc2516566c13ec6713c624cdfd2c21">back</a> () const</td></tr>
<tr class="memdesc:a01dc2516566c13ec6713c624cdfd2c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a01dc2516566c13ec6713c624cdfd2c21">More...</a><br /></td></tr>
<tr class="separator:a01dc2516566c13ec6713c624cdfd2c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19e208064355c8176eeffa1c832cdd5"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5">cback</a> () const</td></tr>
<tr class="memdesc:af19e208064355c8176eeffa1c832cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#af19e208064355c8176eeffa1c832cdd5">More...</a><br /></td></tr>
<tr class="separator:af19e208064355c8176eeffa1c832cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10579fdbcf3a682355025954d4ba665f"><td class="memItemLeft" align="right" valign="top">value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f">data</a> ()</td></tr>
<tr class="memdesc:a10579fdbcf3a682355025954d4ba665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns raw pointer to the underlying data and adds entire array to a transaction.  <a href="#a10579fdbcf3a682355025954d4ba665f">More...</a><br /></td></tr>
<tr class="separator:a10579fdbcf3a682355025954d4ba665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9561c662b97f84da5e47e0f767f9bde"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad9561c662b97f84da5e47e0f767f9bde">data</a> () const noexcept</td></tr>
<tr class="memdesc:ad9561c662b97f84da5e47e0f767f9bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#ad9561c662b97f84da5e47e0f767f9bde">More...</a><br /></td></tr>
<tr class="separator:ad9561c662b97f84da5e47e0f767f9bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memItemLeft" align="right" valign="top">const value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:a8a3543940ea0b583b71e96ec3a89c68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const raw pointer to the underlying data.  <a href="#a8a3543940ea0b583b71e96ec3a89c68a">More...</a><br /></td></tr>
<tr class="separator:a8a3543940ea0b583b71e96ec3a89c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88d348f9aec780a683e0572b60be83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83">begin</a> ()</td></tr>
<tr class="memdesc:aab88d348f9aec780a683e0572b60be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#aab88d348f9aec780a683e0572b60be83">More...</a><br /></td></tr>
<tr class="separator:aab88d348f9aec780a683e0572b60be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb307d36ab9098655ba1a1166d37444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3cb307d36ab9098655ba1a1166d37444">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a3cb307d36ab9098655ba1a1166d37444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#a3cb307d36ab9098655ba1a1166d37444">More...</a><br /></td></tr>
<tr class="separator:a3cb307d36ab9098655ba1a1166d37444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aae52abd4d3c066bf755b78f4b781c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning.  <a href="#aae52abd4d3c066bf755b78f4b781c1d8">More...</a><br /></td></tr>
<tr class="separator:aae52abd4d3c066bf755b78f4b781c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d32b0060badd059f0ac41eb73bf54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54">end</a> ()</td></tr>
<tr class="memdesc:aac5d32b0060badd059f0ac41eb73bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to past the end.  <a href="#aac5d32b0060badd059f0ac41eb73bf54">More...</a><br /></td></tr>
<tr class="separator:aac5d32b0060badd059f0ac41eb73bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289592fadece20471f1588c0a1bddb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa289592fadece20471f1588c0a1bddb3">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa289592fadece20471f1588c0a1bddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to past the end.  <a href="#aa289592fadece20471f1588c0a1bddb3">More...</a><br /></td></tr>
<tr class="separator:aa289592fadece20471f1588c0a1bddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end.  <a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">More...</a><br /></td></tr>
<tr class="separator:ac1f050f7fabb39ec5918fbc1fb3604ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec3d65c0203596140b72b21581c795"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795">rbegin</a> ()</td></tr>
<tr class="memdesc:abdec3d65c0203596140b72b21581c795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#abdec3d65c0203596140b72b21581c795">More...</a><br /></td></tr>
<tr class="separator:abdec3d65c0203596140b72b21581c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2904e853e49b5abf858e08199fe3a361"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2904e853e49b5abf858e08199fe3a361">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2904e853e49b5abf858e08199fe3a361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a2904e853e49b5abf858e08199fe3a361">More...</a><br /></td></tr>
<tr class="separator:a2904e853e49b5abf858e08199fe3a361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767248672d1dde6231a2edf45e4edad"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a0767248672d1dde6231a2edf45e4edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a0767248672d1dde6231a2edf45e4edad">More...</a><br /></td></tr>
<tr class="separator:a0767248672d1dde6231a2edf45e4edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b79d6c2a9f83b2b786a7a38951431"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431">rend</a> ()</td></tr>
<tr class="memdesc:a301b79d6c2a9f83b2b786a7a38951431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a301b79d6c2a9f83b2b786a7a38951431">More...</a><br /></td></tr>
<tr class="separator:a301b79d6c2a9f83b2b786a7a38951431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ad8102a1af5ef750fc2da054a6cfb3f1b">rend</a> () const noexcept</td></tr>
<tr class="memdesc:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the end.  <a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">More...</a><br /></td></tr>
<tr class="separator:ad8102a1af5ef750fc2da054a6cfb3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a9669cf45a5270311bbd00c3da4cd0c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the beginning.  <a href="#a9669cf45a5270311bbd00c3da4cd0c41">More...</a><br /></td></tr>
<tr class="separator:a9669cf45a5270311bbd00c3da4cd0c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68621a1b88210bc2cac19f5218f7be5d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a68621a1b88210bc2cac19f5218f7be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a68621a1b88210bc2cac19f5218f7be5d">More...</a><br /></td></tr>
<tr class="separator:a68621a1b88210bc2cac19f5218f7be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae5f550e26055428de5c6bfbe103a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a> () const noexcept</td></tr>
<tr class="separator:a47ae5f550e26055428de5c6bfbe103a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size</a> () const noexcept</td></tr>
<tr class="separator:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a724b7a93aa0f7eec8847bbc9d3f8bf0a">reserve</a> (size_type capacity_new)</td></tr>
<tr class="memdesc:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of the vector to capacity_new transactionally.  <a href="#a724b7a93aa0f7eec8847bbc9d3f8bf0a">More...</a><br /></td></tr>
<tr class="separator:a724b7a93aa0f7eec8847bbc9d3f8bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6f34cabfe6535991feacf04745536"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity</a> () const noexcept</td></tr>
<tr class="separator:a48c6f34cabfe6535991feacf04745536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae559c0be703f3dcbf0674ce4619cba40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae559c0be703f3dcbf0674ce4619cba40">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ae559c0be703f3dcbf0674ce4619cba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests transactional removal of unused capacity.  <a href="#ae559c0be703f3dcbf0674ce4619cba40">More...</a><br /></td></tr>
<tr class="separator:ae559c0be703f3dcbf0674ce4619cba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a206dfb1d76ce938b31d1ce9eed93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a800a206dfb1d76ce938b31d1ce9eed93">clear</a> ()</td></tr>
<tr class="memdesc:a800a206dfb1d76ce938b31d1ce9eed93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector transactionally.  <a href="#a800a206dfb1d76ce938b31d1ce9eed93">More...</a><br /></td></tr>
<tr class="separator:a800a206dfb1d76ce938b31d1ce9eed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008f5170008840628525c7e8327a2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a6008f5170008840628525c7e8327a2e2">free_data</a> ()</td></tr>
<tr class="memdesc:a6008f5170008840628525c7e8327a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector and frees all allocated persistent memory for data transactionally.  <a href="#a6008f5170008840628525c7e8327a2e2">More...</a><br /></td></tr>
<tr class="separator:a6008f5170008840628525c7e8327a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b95b576242f9fdcdfecfaad1188178b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a5b95b576242f9fdcdfecfaad1188178b">resize</a> (size_type count)</td></tr>
<tr class="memdesc:a5b95b576242f9fdcdfecfaad1188178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to count elements transactionally.  <a href="#a5b95b576242f9fdcdfecfaad1188178b">More...</a><br /></td></tr>
<tr class="separator:a5b95b576242f9fdcdfecfaad1188178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a66eb353a0725e84d14b18b9b5fc325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a1a66eb353a0725e84d14b18b9b5fc325">resize</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a1a66eb353a0725e84d14b18b9b5fc325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements transactionally.  <a href="#a1a66eb353a0725e84d14b18b9b5fc325">More...</a><br /></td></tr>
<tr class="separator:a1a66eb353a0725e84d14b18b9b5fc325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ed01e57919aa22d333b13ef2087bf"><td class="memItemLeft" align="right" valign="top"><a id="a3a1ed01e57919aa22d333b13ef2087bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3a1ed01e57919aa22d333b13ef2087bf">swap</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a3a1ed01e57919aa22d333b13ef2087bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with other transactionally. <br /></td></tr>
<tr class="separator:a3a1ed01e57919aa22d333b13ef2087bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ab667822e6db1a4ed0ea917ab75b5e02e">_alloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ab667822e6db1a4ed0ea917ab75b5e02e">More...</a><br /></td></tr>
<tr class="separator:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4b850a420442f46d30ab3f6f61a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af5a4b850a420442f46d30ab3f6f61a64">_check_pmem</a> ()</td></tr>
<tr class="memdesc:af5a4b850a420442f46d30ab3f6f61a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#af5a4b850a420442f46d30ab3f6f61a64">More...</a><br /></td></tr>
<tr class="separator:af5a4b850a420442f46d30ab3f6f61a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b4dd6e194896d5e1a8143338f245ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a52b4dd6e194896d5e1a8143338f245ae">_check_tx_stage_work</a> ()</td></tr>
<tr class="memdesc:a52b4dd6e194896d5e1a8143338f245ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a52b4dd6e194896d5e1a8143338f245ae">More...</a><br /></td></tr>
<tr class="separator:a52b4dd6e194896d5e1a8143338f245ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55506a53b2f29e68def838b8c32bc25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae55506a53b2f29e68def838b8c32bc25">_dealloc</a> ()</td></tr>
<tr class="memdesc:ae55506a53b2f29e68def838b8c32bc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ae55506a53b2f29e68def838b8c32bc25">More...</a><br /></td></tr>
<tr class="separator:ae55506a53b2f29e68def838b8c32bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d230c82cfe442fb366399812c362889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a5d230c82cfe442fb366399812c362889">_get_pool</a> () const noexcept</td></tr>
<tr class="memdesc:a5d230c82cfe442fb366399812c362889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a5d230c82cfe442fb366399812c362889">More...</a><br /></td></tr>
<tr class="separator:a5d230c82cfe442fb366399812c362889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9e900597e407247e7c0e3d9dc1b0734e">_grow</a> (size_type count, const_reference value)</td></tr>
<tr class="memdesc:a9e900597e407247e7c0e3d9dc1b0734e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a9e900597e407247e7c0e3d9dc1b0734e">More...</a><br /></td></tr>
<tr class="separator:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f1881a92ee7c1a868177b0b389e77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af8f1881a92ee7c1a868177b0b389e77e">_grow</a> (size_type count)</td></tr>
<tr class="memdesc:af8f1881a92ee7c1a868177b0b389e77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#af8f1881a92ee7c1a868177b0b389e77e">More...</a><br /></td></tr>
<tr class="separator:af8f1881a92ee7c1a868177b0b389e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2e8c0c53838d13b751004eab5b60c4e7">_grow</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a2e8c0c53838d13b751004eab5b60c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2e8c0c53838d13b751004eab5b60c4e7">More...</a><br /></td></tr>
<tr class="separator:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a30e3e5c8dd6707a3ce6776292262ac"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a30e3e5c8dd6707a3ce6776292262ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9a30e3e5c8dd6707a3ce6776292262ac">_grow_copy</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9a30e3e5c8dd6707a3ce6776292262ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a9a30e3e5c8dd6707a3ce6776292262ac">More...</a><br /></td></tr>
<tr class="separator:a9a30e3e5c8dd6707a3ce6776292262ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f71521607debe89913cef2ca9dd53ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a1f71521607debe89913cef2ca9dd53ed">_realloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:a1f71521607debe89913cef2ca9dd53ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a1f71521607debe89913cef2ca9dd53ed">More...</a><br /></td></tr>
<tr class="separator:a1f71521607debe89913cef2ca9dd53ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ce37d119d23b37b10984dbfb3380e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ce37d119d23b37b10984dbfb3380e3">_shrink</a> (size_type size_new)</td></tr>
<tr class="memdesc:ae5ce37d119d23b37b10984dbfb3380e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ae5ce37d119d23b37b10984dbfb3380e3">More...</a><br /></td></tr>
<tr class="separator:ae5ce37d119d23b37b10984dbfb3380e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::vector&lt; T &gt;</h3>

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a636c3f33b0647feb03e1caf9aece8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c3f33b0647feb03e1caf9aece8ab2">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77628ae4d95b0e93037541f104ec86b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77628ae4d95b0e93037541f104ec86b3">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486b0a598e44399198a1f05ee732e576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b0a598e44399198a1f05ee732e576">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of T default constructed values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f6b898490147e4c6e620785d5194aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6b898490147e4c6e620785d5194aa">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>The first and last arguments must satisfy InputIterator requirements. This overload only participates in overload resolution if InputIt satisfies InputIterator, to avoid ambiguity with the overload of count-value constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1167a0629de37532aa57f39da47fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1167a0629de37532aa57f39da47fa9">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa503ab924495ac60140b9852ce7d52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503ab924495ac60140b9852ce7d52b0">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d" title="Checks whether the container is empty. ">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the vector to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == other.data() </dd>
<dd>
other.data() == nullptr </dd>
<dd>
other.capacity() == 0 </dd>
<dd>
other.size() == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a88f2db2da445af0fab25559262c636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a88f2db2da445af0fab25559262c636">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == init.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395a49f38bcde6c2164405fc9bb2c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a49f38bcde6c2164405fc9bb2c35a">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that free_data may throw an <a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a> when freeing underlying array failed. It is recommended to call free_data manually before object destruction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab667822e6db1a4ed0ea917ab75b5e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667822e6db1a4ed0ea917ab75b5e02e">&#9670;&nbsp;</a></span>_alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_alloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates memory for given number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>capacity of new underlying array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size exceeds biggest possible pmem allocation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a4b850a420442f46d30ab3f6f61a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a4b850a420442f46d30ab3f6f61a64">&#9670;&nbsp;</a></span>_check_pmem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_check_pmem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if vector resides on pmem and throws an exception if not.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pool_error</a></td><td>if vector doesn't reside on pmem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b4dd6e194896d5e1a8143338f245ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b4dd6e194896d5e1a8143338f245ae">&#9670;&nbsp;</a></span>_check_tx_stage_work()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_check_tx_stage_work </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Checks if current transaction stage is equal to TX_STAGE_WORK and throws an exception otherwise.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if current transaction stage is not equal to TX_STAGE_WORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae55506a53b2f29e68def838b8c32bc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55506a53b2f29e68def838b8c32bc25">&#9670;&nbsp;</a></span>_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_dealloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Deallocates underlying array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d230c82cfe442fb366399812c362889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d230c82cfe442fb366399812c362889">&#9670;&nbsp;</a></span>_get_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1pool__base.html">pool_base</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_get_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="classpmem_1_1obj_1_1pool__base.html" title="The non-template pool base class. ">pool_base</a> object where vector resides.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>underlying array must reside in persistent memory pool. </dd></dl>

</div>
</div>
<a id="a9e900597e407247e7c0e3d9dc1b0734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e900597e407247e7c0e3d9dc1b0734e">&#9670;&nbsp;</a></span>_grow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements. Copy constructs elements at the end of underlying array based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + count) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= count + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
value is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8f1881a92ee7c1a868177b0b389e77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f1881a92ee7c1a868177b0b389e77e">&#9670;&nbsp;</a></span>_grow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements. Constructs default elements at the end of underlying array based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + count) must be snapshotted in current transaction </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= count + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8c0c53838d13b751004eab5b60c4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8c0c53838d13b751004eab5b60c4e7">&#9670;&nbsp;</a></span>_grow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements and input arguments satisfy InputIterator requirements. Constructs elements in underlying array with the contents of the range [first, last). This overload participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
std::move(InputIt::reference) is valid argument for value_type constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a30e3e5c8dd6707a3ce6776292262ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a30e3e5c8dd6707a3ce6776292262ac">&#9670;&nbsp;</a></span>_grow_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements and input arguments satisfy InputIterator requirements. Copy-constructs elements in underlying array with the contents of the range [first, last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
InputIt::reference is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f71521607debe89913cef2ca9dd53ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f71521607debe89913cef2ca9dd53ed">&#9670;&nbsp;</a></span>_realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_realloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates new memory for capacity_new number of elements and copies or moves old elements to new memory area. If the current size is greater than capacity_new, the container is reduced to its first capacity_new elements.</p>
<p>param[in] capacity_new new capacity.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if not initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>) must be snapshotted in current transaction</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ce37d119d23b37b10984dbfb3380e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ce37d119d23b37b10984dbfb3380e3">&#9670;&nbsp;</a></span>_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_shrink </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Destroys elements in underlying array beginning from position size_new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_new</td><td>new size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>) must be snapshotted in current transaction. </dd>
<dd>
size_new &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == size_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b1f1a08b1d34f9874c1d56dce9c8ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1f1a08b1d34f9874c1d56dce9c8ec8">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking and add it to a transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83db43b38bad316d12f51319fcdb2054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db43b38bad316d12f51319fcdb2054">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0014916c3340dfafdcba429a3afd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0014916c3340dfafdcba429a3afd4a">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the last element in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01dc2516566c13ec6713c624cdfd2c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dc2516566c13ec6713c624cdfd2c21">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aab88d348f9aec780a683e0572b60be83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88d348f9aec780a683e0572b60be83">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="a3cb307d36ab9098655ba1a1166d37444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb307d36ab9098655ba1a1166d37444">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a48c6f34cabfe6535991feacf04745536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c6f34cabfe6535991feacf04745536">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements that can be held in currently allocated storage </dd></dl>

</div>
</div>
<a id="af19e208064355c8176eeffa1c832cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19e208064355c8176eeffa1c832cdd5">&#9670;&nbsp;</a></span>cback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the last element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a4c0014916c3340dfafdcba429a3afd4a" title="Access the last element and add this element to a transaction. ">back()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#af19e208064355c8176eeffa1c832cdd5" title="Access the last element. ">cback()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in underlying array. </dd></dl>

</div>
</div>
<a id="aae52abd4d3c066bf755b78f4b781c1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae52abd4d3c066bf755b78f4b781c1d8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aae52abd4d3c066bf755b78f4b781c1d8" title="Returns const iterator to the beginning. ">cbegin()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to the first element in the vector. </dd></dl>

</div>
</div>
<a id="a8a3543940ea0b583b71e96ec3a89c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3543940ea0b583b71e96ec3a89c68a">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> will return const_pointer not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8a3543940ea0b583b71e96ec3a89c68a" title="Returns const raw pointer to the underlying data. ">cdata()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="ac1f050f7fabb39ec5918fbc1fb3604ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f050f7fabb39ec5918fbc1fb3604ba">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ac1f050f7fabb39ec5918fbc1fb3604ba" title="Returns a const iterator to the end. ">cend()</a> will return const_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="abbfb83c8e3bda44858a6923319e880e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb83c8e3bda44858a6923319e880e6">&#9670;&nbsp;</a></span>cfront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::cfront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae5ea56dd1be6b3e5d0427a62327b81e5" title="Access the first element and add this element to a transaction. ">front()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abbfb83c8e3bda44858a6923319e880e6" title="Access the first element. ">cfront()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="a800a206dfb1d76ce938b31d1ce9eed93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a206dfb1d76ce938b31d1ce9eed93">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fc08c07d12cdacc4426285962f0c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc08c07d12cdacc4426285962f0c21">&#9670;&nbsp;</a></span>const_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::const_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index with bounds checking. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7b1f1a08b1d34f9874c1d56dce9c8ec8" title="Access element at specific index with bounds checking and add it to a transaction. ">at()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> will return const_reference not depending on the const-qualification of the object it is called on. std::vector doesn't provide <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a38fc08c07d12cdacc4426285962f0c21" title="Access element at specific index with bounds checking. ">const_at()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if n is not within the range of the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0767248672d1dde6231a2edf45e4edad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0767248672d1dde6231a2edf45e4edad">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#abdec3d65c0203596140b72b21581c795" title="Returns a reverse iterator to the beginning. ">rbegin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a0767248672d1dde6231a2edf45e4edad" title="Returns a const reverse iterator to the beginning. ">crbegin()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a9669cf45a5270311bbd00c3da4cd0c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669cf45a5270311bbd00c3da4cd0c41">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<p>In contradiction to <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a301b79d6c2a9f83b2b786a7a38951431" title="Returns a reverse iterator to the end. ">rend()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9669cf45a5270311bbd00c3da4cd0c41" title="Returns a const reverse iterator to the beginning. ">crend()</a> will return const_reverse_iterator not depending on the const-qualification of the object it is called on.</p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a10579fdbcf3a682355025954d4ba665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10579fdbcf3a682355025954d4ba665f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns raw pointer to the underlying data and adds entire array to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the underlying data.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9561c662b97f84da5e47e0f767f9bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9561c662b97f84da5e47e0f767f9bde">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::value_type * <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const raw pointer to the underlying data. </p>
<dl class="section return"><dt>Returns</dt><dd>const_pointer to the underlying data. </dd></dl>

</div>
</div>
<a id="a68621a1b88210bc2cac19f5218f7be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68621a1b88210bc2cac19f5218f7be5d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="aac5d32b0060badd059f0ac41eb73bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d32b0060badd059f0ac41eb73bf54">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="aa289592fadece20471f1588c0a1bddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289592fadece20471f1588c0a1bddb3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="a6008f5170008840628525c7e8327a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008f5170008840628525c7e8327a2e2">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector and frees all allocated persistent memory for data transactionally. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a10579fdbcf3a682355025954d4ba665f" title="Returns raw pointer to the underlying data and adds entire array to a transaction. ">data()</a> == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ea56dd1be6b3e5d0427a62327b81e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ea56dd1be6b3e5d0427a62327b81e5">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element and add this element to a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to first element in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674fdb0401fd0f7396675035d1d8e72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674fdb0401fd0f7396675035d1d8e72a">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to first element in underlying array. </dd></dl>

</div>
</div>
<a id="a8e55449de7f6a9c04eaf19f3131681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55449de7f6a9c04eaf19f3131681a7">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold due to PMDK limitations. </dd></dl>

</div>
</div>
<a id="a57b4e5d1c66f006ad7f87f9573f3c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to element number n in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f0ffcc2e74974015ed9741b1430227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0ffcc2e74974015ed9741b1430227">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to element number n in underlying array. </dd></dl>

</div>
</div>
<a id="abdec3d65c0203596140b72b21581c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec3d65c0203596140b72b21581c795">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the last element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="a2904e853e49b5abf858e08199fe3a361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2904e853e49b5abf858e08199fe3a361">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a301b79d6c2a9f83b2b786a7a38951431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b79d6c2a9f83b2b786a7a38951431">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to the theoretical element preceding the first element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd></dl>

</div>
</div>
<a id="ad8102a1af5ef750fc2da054a6cfb3f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8102a1af5ef750fc2da054a6cfb3f1b">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reverse_iterator <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the theoretical element preceding the first element in the vector. </dd></dl>

</div>
</div>
<a id="a724b7a93aa0f7eec8847bbc9d3f8bf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724b7a93aa0f7eec8847bbc9d3f8bf0a">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the capacity of the vector to capacity_new transactionally. </p>
<p>If capacity_new is greater than the current <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, new storage is allocated, otherwise the method does nothing. If capacity_new is greater than <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a>, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>new capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == max(capacity(), capacity_new)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname">std::length_error</td><td>if new_cap &gt; <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating new memory failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b95b576242f9fdcdfecfaad1188178b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b95b576242f9fdcdfecfaad1188178b">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional default-inserted elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == std::max(count, capacity()) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a66eb353a0725e84d14b18b9b5fc325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a66eb353a0725e84d14b18b9b5fc325">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements transactionally. </p>
<p>If the current size is greater than count, the container is reduced to its first count elements. If the current size is less than count, additional copies of value are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>new size of the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to initialize the new elements with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::min(_size, count)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae559c0be703f3dcbf0674ce4619cba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae559c0be703f3dcbf0674ce4619cba40">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests transactional removal of unused capacity. </p>
<p>New capacity will be set to current vector size. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when snapshotting failed </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when reallocating failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
    <tr><td class="paramname">rethrows</td><td>destructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47ae5f550e26055428de5c6bfbe103a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae5f550e26055428de5c6bfbe103a8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
